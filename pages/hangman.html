/**
 * NEON HANGMAN (OFFLINE LANG POOL)
 * - /assets/lang/{lang}.json -> ortak havuz
 * - /js/langpool.js -> ortak se√ßim/tekrar engeli
 * - AI yok, backend yok, offline.
 */

import { loadLangPool, createUsedSet, pick } from "/js/langpool.js";

const $ = (id) => document.getElementById(id);

/* =========================
   Dƒ∞L AYARLARI
   ========================= */
let currentLang = "en";
const LANG_CONFIG = {
  en: { code: "en-US", name: "ƒ∞ngilizce" },
  de: { code: "de-DE", name: "Almanca" },
  fr: { code: "fr-FR", name: "Fransƒ±zca" },
  es: { code: "es-ES", name: "ƒ∞spanyolca" },
  it: { code: "it-IT", name: "ƒ∞talyanca" }
};

window.setLang = (lang, el) => {
  currentLang = lang;
  document.querySelectorAll(".lang-btn").forEach((b) => b.classList.remove("active"));
  if (el) el.classList.add("active");
  ensureAudio();
};

/* =========================
   SES (SFX)
   ========================= */
let audioCtx = null;
function ensureAudio() {
  if (!audioCtx) {
    const AC = window.AudioContext || window.webkitAudioContext;
    audioCtx = AC ? new AC() : null;
  }
  if (audioCtx && audioCtx.state === "suspended") audioCtx.resume().catch(() => {});
  return audioCtx;
}

const SFX = {
  click: () => {
    const c = ensureAudio(); if(!c) return;
    const o = c.createOscillator(), g = c.createGain();
    o.frequency.value = 800; o.connect(g); g.connect(c.destination);
    g.gain.setValueAtTime(.05, c.currentTime);
    g.gain.exponentialRampToValueAtTime(.001, c.currentTime + .1);
    o.start(); o.stop(c.currentTime + .1);
  },
  win: () => {
    const c = ensureAudio(); if(!c) return;
    [523,659,783,1046].forEach((f,i)=>{
      const o=c.createOscillator(),g=c.createGain();
      o.frequency.value=f; o.connect(g); g.connect(c.destination);
      g.gain.setValueAtTime(.05,c.currentTime+i*.1);
      g.gain.exponentialRampToValueAtTime(.001,c.currentTime+i*.1+.3);
      o.start(c.currentTime+i*.1); o.stop(c.currentTime+i*.1+.3);
    });
  },
  fail: () => {
    const c = ensureAudio(); if(!c) return;
    const o=c.createOscillator(),g=c.createGain();
    o.type='sawtooth'; o.frequency.value=100;
    o.connect(g); g.connect(c.destination);
    g.gain.setValueAtTime(.1,c.currentTime);
    g.gain.exponentialRampToValueAtTime(.001,c.currentTime+.5);
    o.start(); o.stop(c.currentTime+.5);
  }
};

/* =========================
   ZORLUK / OYUN AYARLARI
   ========================= */
let difficulty = "A2";
let wordList = [];           // [ [w,tr,sentence], ... ]
let currentIndex = 0;
let currentWord = "";
let mistakes = 0;
let discovered = [];
let score = 0;
let streak = 0;
let powerups = 1;
let currentMaxErrors = 9;
let scoreMultiplier = 1;
let isBossRound = false;

const SETTINGS = {
  A2: { lives: 9, multi: 1,   range: [4, 6] },
  B1: { lives: 7, multi: 1.5, range: [6, 8] },
  B2: { lives: 6, multi: 2,   range: [8,10] }
};

window.selectLevel = async (diff) => {
  difficulty = diff;
  currentMaxErrors = SETTINGS[diff].lives;
  scoreMultiplier = SETTINGS[diff].multi;
  ensureAudio();

  const modalCard = $("startModal")?.querySelector(".modal-card");
  if (modalCard) {
    Array.from(modalCard.children).forEach((c) => {
      // PATCH: className e≈üitliƒüi yerine matches
      const isHide =
        c.matches?.("button") ||
        c.matches?.(".modal-p") ||
        c.matches?.(".lang-grid");
      if (isHide) c.style.display = "none";
    });
  }

  $("loading").style.display = "block";
  await fetchWordsFromPool();
};

/* =========================
   NORMALIZE (HANGMAN i√ßin)
   - diakritik s√∂kme + √∂zel map
   ========================= */
function normalizeCharString(s){
  let t = String(s || "");
  // √ñzel harf e≈ülemeleri
  t = t.replace(/√ü/g, "ss").replace(/√Ü/g, "AE").replace(/√¶/g, "ae").replace(/≈í/g, "OE").replace(/≈ì/g, "oe");
  // diakritik s√∂k
  t = t.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
  return t.toUpperCase();
}

/* =========================
   C√úMLE ≈ûABLONU (Dƒ∞LE G√ñRE)  ‚úÖ PATCH
   ========================= */
function buildSentenceByLang(word, pos){
  const w = String(word || "").trim();
  if(!w) return "";

  const L = currentLang;

  // minimal, basit, offline ≈üablonlar
  const templates = {
    en: {
      verb: `I ${w} every day.`,
      adj:  `It is ${w}.`,
      adv:  `I do it ${w}.`,
      noun: `This is ${w}.`
    },
    de: {
      verb: `Ich ${w} jeden Tag.`,
      adj:  `Es ist ${w}.`,
      adv:  `Ich mache es ${w}.`,
      noun: `Das ist ${w}.`
    },
    fr: {
      verb: `Je ${w} chaque jour.`,
      adj:  `C'est ${w}.`,
      adv:  `Je le fais ${w}.`,
      noun: `C'est ${w}.`
    },
    es: {
      verb: `Yo ${w} todos los d√≠as.`,
      adj:  `Es ${w}.`,
      adv:  `Lo hago ${w}.`,
      noun: `Esto es ${w}.`
    },
    it: {
      verb: `Io ${w} ogni giorno.`,
      adj:  `√à ${w}.`,
      adv:  `Lo faccio ${w}.`,
      noun: `Questo √® ${w}.`
    }
  };

  const pack = templates[L] || templates.en;
  if(pos === "verb") return pack.verb;
  if(pos === "adj") return pack.adj;
  if(pos === "adv") return pack.adv;
  return pack.noun;
}

/* =========================
   ORTAK HAVUZDAN KELƒ∞ME √áEK
   - /assets/lang/{lang}.json
   ========================= */
async function fetchWordsFromPool(){
  const pool = await loadLangPool(currentLang);

  // PATCH: havuz bo≈üsa g√ºvenli √ßƒ±k
  if (!Array.isArray(pool) || pool.length === 0) {
    $("loading").style.display = "none";
    alert("Dil havuzu bo≈ü g√∂r√ºn√ºyor. /assets/lang dosyalarƒ±nƒ± kontrol et.");
    location.reload();
    return;
  }

  const usedKey = `used_hangman_${currentLang}_${difficulty}`;
  const { used, save } = createUsedSet(usedKey);

  const [minLen, maxLen] = SETTINGS[difficulty].range;

  const filterFn = (it) => {
    const posOk = (it.pos === "noun" || it.pos === "verb" || !it.pos);
    const lvlOk =
      (it.lvl === difficulty) ||
      (difficulty==="B1" && it.lvl==="A2") ||
      (difficulty==="B2" && (it.lvl==="B1" || it.lvl==="B2" || it.lvl==="C1"));

    const w = normalizeCharString(it.w).replace(/[^A-Z]/g,"");
    const lenOk = (w.length >= minLen && w.length <= maxLen);
    return posOk && lvlOk && lenOk;
  };

  let picked = pick(pool, 15, used, save, filterFn);

  if(picked.length < 10){
    picked = pick(pool, 15, used, save, (it)=>{
      const posOk = (it.pos === "noun" || it.pos === "verb" || !it.pos);
      const w = normalizeCharString(it.w).replace(/[^A-Z]/g,"");
      return posOk && w.length >= 4 && w.length <= 10;
    });
  }

  // PATCH: yine azsa, hi√ß deƒüilse 10-15 arasƒ± ne varsa oynat
  if (picked.length < 5) {
    $("loading").style.display = "none";
    alert("Bu dil/zorluk kombinasyonunda yeterli kelime yok. Havuzu geni≈ület.");
    location.reload();
    return;
  }

  // sentence √ºret (offline, dile g√∂re) ‚úÖ PATCH
  wordList = picked.map(it => {
    const w = String(it.w || "").trim();
    const tr = String(it.tr || "").trim();
    // pool i√ßinde √∂rnek c√ºmle varsa onu tercih edelim
    const sent = String(it.sentence || it.ex || "").trim() || buildSentenceByLang(w, it.pos);
    return [w, tr, sent];
  });

  $("startModal").style.display = "none";
  startRun();
}

/* =========================
   OYUN BA≈ûLAT
   ========================= */
function startRun(){
  currentIndex = 0;
  score = 0;
  streak = 0;
  powerups = 1;
  $("loading").style.display = "none";
  startLevel();
}

function startLevel() {
  if (currentIndex >= wordList.length) {
    alert(`Oyun Bitti! Toplam Skor: ${score}`);
    location.reload();
    return;
  }

  isBossRound = (currentIndex + 1) % 5 === 0;
  const trMean = String(wordList[currentIndex][1] || "").toUpperCase();

  if (isBossRound) {
    $("gameStage").classList.add("boss-mode");
    currentMaxErrors = Math.max(4, SETTINGS[difficulty].lives - 1);
    $("hintBox").textContent = `‚ö†Ô∏è BOSS: ${trMean} (CAN: ${currentMaxErrors})`;
  } else {
    $("gameStage").classList.remove("boss-mode");
    currentMaxErrors = SETTINGS[difficulty].lives;
    $("hintBox").textContent = trMean;
  }

  currentWord = normalizeCharString(wordList[currentIndex][0]);

  mistakes = 0;
  discovered = new Array(currentWord.length).fill(false);

  renderWord();
  renderHangman();
  generateKeyboard();
  updateScoreUI();
}

/* =========================
   UI RENDER
   ========================= */
function renderWord() {
  const container = $("wordBox");
  container.innerHTML = "";
  for (let i = 0; i < currentWord.length; i++) {
    const span = document.createElement("div");

    if (!/[A-Z]/.test(currentWord[i])) {
      span.className = "letter-slot filled";
      span.textContent = currentWord[i];
      span.style.border = "none";
      discovered[i] = true;
    } else {
      span.className = "letter-slot " + (discovered[i] ? "filled" : "");
      span.textContent = discovered[i] ? currentWord[i] : "";
    }
    container.appendChild(span);
  }
}

function renderHangman() {
  const parts = 9;
  const shown = Math.min(parts, Math.ceil((mistakes / currentMaxErrors) * parts));
  for (let i = 1; i <= parts; i++) {
    const el = document.querySelector(`.p${i}`);
    if (el) el.style.opacity = (i <= shown) ? 1 : 0;
  }
}

function generateKeyboard() {
  const kb = $("keyboard");
  kb.innerHTML = "";

  const onlyLetters = currentWord.replace(/[^A-Z]/g, "");
  const poolSet = new Set(onlyLetters.split(""));

  const common = "ETAOINSHRDLUCMPFGYWBVKXJQZ";
  let totalKeys = (difficulty === "B2") ? 18 : 14;

  let guard = 0;
  while (poolSet.size < totalKeys && guard < 200) {
    const char = common[Math.floor(Math.random() * common.length)];
    poolSet.add(char);
    guard++;
  }

  const pool = Array.from(poolSet).sort(() => Math.random() - 0.5);

  pool.forEach((char) => {
    const btn = document.createElement("div");
    btn.className = "key-btn";
    btn.id = `key-${char}`;
    btn.textContent = char;
    btn.onclick = () => handleGuess(char, btn);
    kb.appendChild(btn);
  });
}

function handleGuess(char, btn) {
  if (btn.classList.contains("used")) return;
  SFX.click();
  btn.classList.add("used");

  if (currentWord.includes(char)) {
    btn.classList.add("correct");

    for (let i = 0; i < currentWord.length; i++) {
      if (currentWord[i] === char) discovered[i] = true;
    }

    renderWord();

    const allFound = discovered.every(Boolean);
    if (allFound) {
      SFX.win();

      const basePoints = (currentMaxErrors - mistakes) * 10;
      const streakBonus = (streak + 1) * 5;
      const roundScore = Math.floor((basePoints + streakBonus) * scoreMultiplier);
      score += roundScore;

      streak++;
      if (streak % 3 === 0) powerups++;

      updateScoreUI();
      if (streak > 1) startConfetti();

      setTimeout(() => { currentIndex++; startLevel(); }, 1500);
    }

  } else {
    btn.classList.add("wrong");
    mistakes++;
    renderHangman();

    if (streak > 0) {
      streak = 0;
      updateScoreUI();
      const oldHint = $("hintBox").textContent;
      $("hintBox").textContent = "üí• STREAK KIRILDI!";
      $("hintBox").classList.add("alert");
      setTimeout(() => {
        $("hintBox").textContent = oldHint;
        $("hintBox").classList.remove("alert");
      }, 1000);
    }

    if (mistakes >= currentMaxErrors) {
      SFX.fail();
      teacherSolve();
    }
  }
}

/* =========================
   POWER UP
   ========================= */
window.usePowerUp = () => {
  // PATCH: Boss round‚Äôda tƒ±klama ile de kilitle
  if (isBossRound) return;
  if (powerups <= 0) return;

  let hiddenIndices = [];
  for (let i = 0; i < currentWord.length; i++) {
    if (!discovered[i] && /[A-Z]/.test(currentWord[i])) hiddenIndices.push(i);
  }
  if (hiddenIndices.length === 0) return;

  SFX.click();
  powerups--;

  const rndIdx = hiddenIndices[Math.floor(Math.random() * hiddenIndices.length)];
  const charToReveal = currentWord[rndIdx];

  for (let i = 0; i < currentWord.length; i++) {
    if (currentWord[i] === charToReveal) discovered[i] = true;
  }

  const btn = $(`key-${charToReveal}`);
  if (btn) {
    btn.classList.remove("wrong");
    btn.classList.add("used", "correct");
  }

  renderWord();
  updateScoreUI();

  const allFound = discovered.every(Boolean);
  if (allFound) {
    setTimeout(() => {
      SFX.win();
      score += 10;
      currentIndex++;
      startLevel();
    }, 1000);
  }
};

function updateScoreUI() {
  $("scoreDisplay").textContent = score;

  const sb = $("streakDisplay");
  if (streak > 1) {
    sb.textContent = `üî• STREAK: ${streak}`;
    sb.style.display = "inline-block";
    sb.classList.add("active");
  } else {
    sb.style.display = "none";
    sb.classList.remove("active");
  }

  const pb = $("btnPowerUp");
  $("powerCount").textContent = powerups;
  if (powerups > 0 && !isBossRound) pb.classList.remove("disabled");
  else pb.classList.add("disabled");
}

/* =========================
   FAIL -> TEACHER SOLVE
   ========================= */
function pickVoiceFor(langCode){
  try {
    const voices = window.speechSynthesis?.getVoices?.() || [];
    if (!voices.length) return null;

    // tam e≈üle≈üme
    let v = voices.find(x => (x.lang || "").toLowerCase() === langCode.toLowerCase());
    if (v) return v;

    // dil kƒ±smƒ± e≈üle≈üme (de / fr / es / it / en)
    const short = langCode.split("-")[0].toLowerCase();
    v = voices.find(x => (x.lang || "").toLowerCase().startsWith(short));
    return v || null;
  } catch {
    return null;
  }
}

function teacherSolve() {
  try { window.speechSynthesis.cancel(); } catch {}

  const slots = document.querySelectorAll(".letter-slot");
  for (let i = 0; i < currentWord.length; i++) {
    if (!discovered[i] && slots[i]) {
      slots[i].textContent = currentWord[i];
      slots[i].classList.add("missed");
    }
  }

  const w = wordList[currentIndex];
  const lessonText = `${w[0]}. ${w[1]}. ${w[2] || ""}`.trim();

  const goNext = () => { setTimeout(() => { currentIndex++; startLevel(); }, 1000); };

  // PATCH: SpeechSynthesis yoksa patlama, direkt ge√ß
  if (!("speechSynthesis" in window) || !("SpeechSynthesisUtterance" in window)) {
    goNext();
    return;
  }

  const u = new SpeechSynthesisUtterance(lessonText);
  u.lang = LANG_CONFIG[currentLang].code;
  u.rate = 0.85;

  // PATCH: uygun voice se√ß (varsa)
  const v = pickVoiceFor(u.lang);
  if (v) u.voice = v;

  u.onend = goNext;
  u.onerror = goNext;

  // Bazƒ± tarayƒ±cƒ±larda voices async gelir; yine de konu≈ümayƒ± ba≈ülat
  try { window.speechSynthesis.speak(u); }
  catch { goNext(); }
}

// PATCH: voices listesi ge√ß gelirse dolduralƒ±m
try {
  window.speechSynthesis.onvoiceschanged = () => {};
} catch {}

$("btnPowerUp")?.addEventListener("click", () => window.usePowerUp());

/* =========================
   CONFETTI
   ========================= */
const cvs = $("effectCanvas"), ctx = cvs.getContext("2d");
let particles = [];

function startConfetti() {
  particles = [];
  cvs.style.display = "block";
  cvs.width = window.innerWidth;
  cvs.height = window.innerHeight;

  for (let i = 0; i < 30; i++) {
    particles.push({
      x: cvs.width / 2,
      y: cvs.height / 2,
      vx: (Math.random() - .5) * 15,
      vy: (Math.random() - .5) * 15,
      color: `hsl(${Math.random() * 360},100%,50%)`,
      life: 50
    });
  }
  requestAnimationFrame(loopConfetti);
}

function loopConfetti() {
  if (particles.length <= 0) { cvs.style.display = "none"; return; }
  ctx.clearRect(0, 0, cvs.width, cvs.height);

  for (let i = 0; i < particles.length; i++) {
    let p = particles[i];
    p.x += p.vx; p.y += p.vy; p.life--;
    ctx.beginPath(); ctx.arc(p.x, p.y, 4, 0, Math.PI * 2);
    ctx.fillStyle = p.color; ctx.fill();
    if (p.life <= 0) { particles.splice(i, 1); i--; }
  }
  requestAnimationFrame(loopConfetti);
}

window.addEventListener("resize", () => {
  if (cvs.style.display === "block") {
    cvs.width = window.innerWidth;
    cvs.height = window.innerHeight;
  }
});
